### @FunctionalInterface란?

함수형 인터페이스는 단 하나의 추상 메서드만 가지는 인터페이스입니다.<br>
Java 8의 람다 표현식과 함께 사용할 수 있습니다.

```java
@FunctionalInterface
private interface SchedulerTask {
    int execute() throws Exception;  // 단 하나의 추상 메서드
}
```

**왜 이렇게 사용했을까?**

Before (함수형 인터페이스 사용 전):
```java
// 코드 중복이 발생
private int executeCleanupWithRetry() throws Exception {
    int maxRetries = Math.max(1, schedulerProperties.getMaxRetries());
    
    for (int attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            return userService.deleteExpiredUnverifiedUsers(); // 이 부분만 다름
        } catch (Exception e) {
            // 재시도 로직 (동일)
        }
    }
}

private int executeHardDeleteWithRetry() throws Exception {
    int maxRetries = Math.max(1, schedulerProperties.getMaxRetries());
    
    for (int attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            return userService.hardDeleteExpiredDeletedUsers(); // 이 부분만 다름
        } catch (Exception e) {
            // 재시도 로직 (동일)
        }
    }
}
```

After (함수형 인터페이스 사용 후):
```java
// 재시도 로직은 한 번만 구현, 실제 작업은 람다로 전달
private int executeWithRetry(SchedulerTask task) throws Exception {
    // 재시도 로직 (공통)
    for (int attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            return task.execute(); // 전달받은 작업 실행
        } catch (Exception e) {
            // 재시도 로직
        }
    }
}

// 사용할 때:
executeWithRetry(() -> userService.deleteExpiredUnverifiedUsers());
executeWithRetry(() -> userService.hardDeleteExpiredDeletedUsers());
```

실제 동작 과정:<br>
1. 람다 표현식으로 작업 전달:
    ```java
    executeWithRetry(() -> userService.deleteExpiredUnverifiedUsers());
    ```
2. SchedulerTask 인터페이스로 받음:
    ```java
    private int executeWithRetry(SchedulerTask task) // task = 람다 표현식
    ```
3. 재시도 로직 안에서 실행:
    ```java
    return task.execute(); // 실제로는 userService.deleteExpiredUnverifiedUsers() 실행
    ```

**장점:**

- 코드 중복 제거: 재시도 로직을 한 번만 구현
- 유연성: 다양한 작업을 동일한 재시도 로직으로 처리 가능
- 가독성: 핵심 로직과 부가 로직(재시도)이 분리됨

다른 예시로 이해하기:
```java
// 함수형 인터페이스 정의
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);
}

// 사용
Calculator add = (a, b) -> a + b;
Calculator multiply = (a, b) -> a * b;

System.out.println(add.calculate(5, 3));      // 8
System.out.println(multiply.calculate(5, 3)); // 15
```

즉, SchedulerTask는 **"실행 가능한 작업"**을 추상화한 것이고, 람다 표현식으로 구체적인 작업을 전달하는 방식입니다!

---

1. 함수형 인터페이스의 동작 원리
    ```java
    @FunctionalInterface
    private interface SchedulerTask {
        int execute() throws Exception;
    }
    ```
    이것은 "실행할 수 있는 어떤 작업"을 나타내는 계약서(contract)입니다.

2. 람다 표현식이 인터페이스로 변환되는 과정
    ```java
    // 이 람다 표현식:
    () -> userService.deleteExpiredUnverifiedUsers()
    
    // 는 실제로 이런 익명 클래스와 같습니다:
    new SchedulerTask() {
        @Override
        public int execute() throws Exception {
            return userService.deleteExpiredUnverifiedUsers();
        }
    }
    ```
   
3. 실제 실행 과정을 단계별로 보면:
    ```java
    // 1단계: 메서드 호출
    executeWithRetry(() -> userService.deleteExpiredUnverifiedUsers());
    
    // 2단계: 람다가 SchedulerTask 객체로 변환됨
    SchedulerTask task = () -> userService.deleteExpiredUnverifiedUsers();
    
    // 3단계: executeWithRetry 메서드 안에서
    private int executeWithRetry(SchedulerTask task) throws Exception {
        // ...
        try {
            return task.execute(); // 여기서 실제 람다 코드가 실행됨!
        }
        // ...
    }
    ```

4. task.execute() 호출 시 실제로 일어나는 일:
    ```java
    // task.execute()가 호출되면:
    // 1. 람다 표현식의 body가 실행됨
    // 2. 즉, userService.deleteExpiredUnverifiedUsers()가 실행됨
    // 3. 그 결과값(int)이 리턴됨
    ```

5. 더 간단한 예시로 이해하기:
    ```java
    // 함수형 인터페이스 정의
    @FunctionalInterface
    interface Printer {
        void print();
    }
    
    // 사용 예시
    public void executePrint(Printer printer) {
        System.out.println("작업 시작");
        printer.print(); // 여기서 전달받은 람다가 실행됨!
        System.out.println("작업 완료");
    }
    
    // 호출
    executePrint(() -> System.out.println("안녕하세요!"));
    
    // 실행 결과:
    // 작업 시작
    // 안녕하세요!
    // 작업 완료
    ```

6. 우리 코드에서의 실제 흐름:
    ```java
    // 호출:
    executeWithRetry(() -> userService.deleteExpiredUnverifiedUsers());
    
    // executeWithRetry 메서드 안에서:
    for (int attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            return task.execute(); // 이 순간 userService.deleteExpiredUnverifiedUsers() 실행!
        } catch (Exception e) {
            // 재시도 로직
        }
    }
    ```

핵심: task.execute()는 람다 표현식에 담긴 실제 코드 userService.deleteExpiredUnverifiedUsers()를 실행하는 것입니다!