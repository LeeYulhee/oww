### 중첩 트랜잭션 문제


```java
@Service
public class AuthFacade {
    
    @Transactional // 외부 트랜잭션
    public void signUp(CreateUserReq req) {
        userService.createUser(user); // 내부에 @Transactional
        emailVerificationService.createEmailVerification(user, emailToken); // 내부에 @Transactional
    }
}
```

**Spring의 트랜잭션 전파(Propagation) 동작:**
- 기본 설정: PROPAGATION_REQUIRED
- 외부에 트랜잭션이 있으면 같은 트랜잭션에 참여
- 외부에 없으면 새로 생성

**문제점:**
- AuthFacade의 @Transactional이 불필요해짐
- 트랜잭션 경계가 애매해짐 (어디서 시작되는지 헷갈림)

**중첩 트랜잭션**
- 같은 트랜잭션에 참여함 (Spring 기본 전파 규칙)
- AuthFacade에 @Transactional이 있으면 모든 하위 서비스 메서드들이 하나의 트랜잭션에서 실행
- 원자성이 필요한 경우에만 AuthFacade에 @Transactional 추가

```java
// 트랜잭션 전파 동작 상세 예시

// UserService
@Service
@Transactional(readOnly = true)
public class UserService {
    
    @Transactional // readOnly=false
    public void createUser(User user) {
        userRepository.save(user);
        // 만약 여기서 예외 발생하면?
    }
    
    @Transactional
    public void updateUserStatusActive(User user) {
        user.updateUserStatusActive();
        // 만약 여기서 예외 발생하면?
    }
}

// EmailVerificationService 
@Service
public class EmailVerificationService {
    
    @Transactional
    public void createEmailVerification(User user, String token) {
        // ... 저장 로직
    }
    
    @Transactional
    public void updateEmailVerification(EmailVerification verification) {
        verification.updateEmailVerification();
    }
}

// AuthFacade
@Service
public class AuthFacade {
    
    // 케이스 1: AuthFacade에 @Transactional 없음
    public void signUp(CreateUserReq req) {
        userService.createUser(user);                    // TX1 시작 → 커밋
        emailService.createEmailVerification(user, token); // TX2 시작 → 커밋
        
        // 문제: emailService에서 실패해도 user는 이미 저장됨!
    }
    
    // 케이스 2: AuthFacade에 @Transactional 있음
    @Transactional
    public void signUpAtomic(CreateUserReq req) {
        userService.createUser(user);                    // 기존 TX에 참여
        emailService.createEmailVerification(user, token); // 기존 TX에 참여
        
        // 장점: 둘 중 하나라도 실패하면 전체 롤백!
        // 단점: 트랜잭션이 길어질 수 있음 (이메일 발송까지 포함되면...)
    }
}

// 실제 트랜잭션 경계 시각화

/*
케이스 1: 독립 트랜잭션
Timeline: |----TX1----|  |----TX2----|
Method:   createUser()   createEmail()
Result:   SUCCESS        FAILURE
DB State: User 저장됨    EmailVerification 저장 안됨

케이스 2: 하나의 트랜잭션  
Timeline: |------------- TX1 ----------------|
Method:   createUser()      createEmail()
Result:   SUCCESS           FAILURE  
Action:                     전체 ROLLBACK
DB State: 둘 다 저장 안됨 (원자성 보장)
*/

// 실제 추천하는 패턴

@Service
public class AuthFacade {
    
    /**
     * 회원가입: 원자성이 중요하므로 하나의 트랜잭션으로 처리
     */
    @Transactional
    public void signUp(CreateUserReq req) {
        User user = CreateUserReq.toEntity(req, passwordEncoder.encode(req.getPassword()));
        userService.createUser(user);               // 기존 TX에 참여

        String emailToken = tokenService.generateVerificationToken(user.getId(), user.getEmail(), VerificationType.SIGNUP);
        emailVerificationService.createEmailVerification(user, emailToken); // 기존 TX에 참여

        // 이메일 발송은 트랜잭션 외부에서 (비동기 이벤트로)
        applicationEventPublisher.publishEvent(new SendVerificationEmailEvent(user.getEmail(), emailToken));
    }
    
    /**
     * 이메일 재발송: 조회만 하므로 트랜잭션 불필요
     */
    public void resendEmail(ResendEmailReq req) {
        User user = userService.findByEmailAndIsDeletedFalse(req.getEmail());
        EmailVerification verification = emailVerificationService.findByUserAndVerificationTypeAndVerificationAtIsNull(user, req.getType());
        
        applicationEventPublisher.publishEvent(new ResendVerificationEmailEvent(user.getEmail(), verification.getVerificationToken()));
    }
    
    /**
     * 이메일 인증: 원자성이 중요하므로 하나의 트랜잭션으로 처리
     */
    @Transactional
    public void verifyEmail(String token) {
        EmailVerification verification = getValidEmailVerification(token);
        User user = verification.getUser();

        userService.updateUserStatusActive(user);           // 기존 TX에 참여
        emailVerificationService.updateEmailVerification(verification); // 기존 TX에 참여
    }
}

// 트랜잭션 전파 규칙 요약

/*
Spring 기본 전파 규칙 (PROPAGATION_REQUIRED):

1. 외부에 트랜잭션이 있으면:
   → 기존 트랜잭션에 참여 (같은 트랜잭션)
   
2. 외부에 트랜잭션이 없으면:
   → 새로운 트랜잭션 생성

3. readOnly 속성:
   → 외부 트랜잭션이 readOnly=false면 내부도 readOnly=false
   → 외부 트랜잭션이 readOnly=true면 내부 readOnly=false는 무시됨
*/
```

### 중첩 트랜잭션을 비선호하는 이유(문제점)
1. 예측하기 어려운 동작

   - 코드만 봐서는 트랜잭션 경계를 알기 어려움
   - 롤백 시점과 범위가 불분명

2. 디버깅의 악몽
   - UnexpectedRollbackException 같은 예상치 못한 오류
   - 어느 서비스에서 롤백이 시작되었는지 추적 어려움
3. 성능 문제
   - 트랜잭션이 길어질수록 DB 락 유지 시간 증가
   - 커넥션 풀 고갈 위험
4. 테스트 복잡성
   - 트랜잭션 경계가 테스트와 실제 환경에서 다르게 동작할 수 있음

```java
// 중첩 트랜잭션의 문제점들

// 1. 트랜잭션 경계가 불분명해짐
@Service
public class AuthFacade {
    
    @Transactional // 외부 트랜잭션
    public void signUp(CreateUserReq req) {
        userService.createUser(user);                    // 내부 @Transactional
        emailService.createEmailVerification(user, token); // 내부 @Transactional  
        groupService.createDefaultGroup(user);           // 내부 @Transactional
        
        // 문제: 어디서 트랜잭션이 시작되고 끝나는지 헷갈림!
        // 코드만 봐서는 각각 독립 트랜잭션인지 하나의 트랜잭션인지 모름
    }
}

// 2. 예상치 못한 롤백 동작
@Service
public class UserService {
    
    @Transactional
    public void createUser(User user) {
        userRepository.save(user);
        
        // 검증 실패 시 RuntimeException
        if (user.getEmail().contains("test")) {
            throw new IllegalArgumentException("테스트 이메일은 허용되지 않습니다");
        }
    }
}

@Service
public class AuthFacade {
    
    @Transactional
    public void signUp(CreateUserReq req) {
        try {
            userService.createUser(user);               // 여기서 예외 발생
            emailService.createEmailVerification(user, token);
        } catch (IllegalArgumentException e) {
            // 예외를 잡았지만...
            log.warn("사용자 생성 실패: {}", e.getMessage());
            
            // 문제: 이미 트랜잭션이 rollback-only로 마킹됨!
            // 이후 emailService 호출해도 의미 없음
            // 결국 UnexpectedRollbackException 발생
        }
    }
}

// 3. 성능 문제 - 긴 트랜잭션
@Service
public class AuthFacade {
    
    @Transactional // 전체가 하나의 긴 트랜잭션
    public void signUp(CreateUserReq req) {
        userService.createUser(user);                    // DB 작업 1
        emailService.createEmailVerification(user, token); // DB 작업 2
        
        // 외부 API 호출 (느림)
        externalApiService.notifyUserRegistration(user); // 3초 소요
        
        // 더 많은 DB 작업들...
        groupService.createDefaultGroup(user);           // DB 작업 3
        
        // 문제: 총 5초 동안 DB 커넥션과 락을 점유!
        // 다른 요청들이 대기하게 됨
    }
}

// 4. 트랜잭션 전파 설정의 복잡성
@Service
public class EmailService {
    
    // 만약 독립적으로 실행되어야 한다면?
    @Transactional(propagation = Propagation.REQUIRES_NEW) // 새 트랜잭션 강제 생성
    public void createEmailVerification(User user, String token) {
        // 이제 외부 트랜잭션과 별도로 실행됨
        // 하지만 코드만 봐서는 이해하기 어려움
    }
}

// 5. 테스트의 복잡성
@ExtendWith(SpringExtension.class)
@Transactional
class AuthFacadeTest {
    
    @Test
    void signUpTest() {
        // 테스트 전체가 트랜잭션으로 감싸짐
        authFacade.signUp(req); // 또 다른 @Transactional 메서드 호출
        
        // 문제: 테스트 트랜잭션 vs 비즈니스 트랜잭션의 경계가 애매
        // 롤백 동작이 예상과 다를 수 있음
    }
}

// 6. 더 나은 패턴들

// 패턴 1: 명확한 트랜잭션 경계
@Service
public class AuthFacade {
    
    @Transactional // 최소한의 트랜잭션 범위
    public void signUp(CreateUserReq req) {
        // 원자성이 필요한 핵심 작업만 포함
        User user = userService.createUser(req);
        emailService.createEmailVerification(user, token);
    }
    
    @Async // 별도 스레드에서 비동기 처리
    public void postSignUpTasks(User user) {
        externalApiService.notifyUserRegistration(user);
        groupService.createDefaultGroup(user);
    }
}

// 패턴 2: 서비스별 독립 트랜잭션
@Service
public class AuthFacade {
    
    public void signUp(CreateUserReq req) {
        // 각 서비스가 자신의 트랜잭션 관리
        User user = userService.createUser(req);           // TX1
        
        try {
            emailService.createEmailVerification(user, token); // TX2
        } catch (Exception e) {
            // 보상 트랜잭션 (Saga 패턴)
            userService.deleteUser(user.getId());          // TX3
            throw e;
        }
    }
}

// 패턴 3: 이벤트 기반 처리
@Service
public class AuthFacade {
    
    @Transactional
    public void signUp(CreateUserReq req) {
        User user = userService.createUser(req);
        
        // 트랜잭션 커밋 후 이벤트 발생
        applicationEventPublisher.publishEvent(new UserCreatedEvent(user.getId()));
    }
}

@EventListener
@Async
public void handleUserCreated(UserCreatedEvent event) {
    // 별도 트랜잭션에서 처리
    emailService.createEmailVerification(event.getUserId());
    groupService.createDefaultGroup(event.getUserId());
}

// 7. 실제 권장 패턴 비교

// ❌ 복잡한 중첩 트랜잭션
@Transactional
public void complexOperation() {
    serviceA.method1(); // @Transactional  
    serviceB.method2(); // @Transactional
    serviceC.method3(); // @Transactional
    // 어디서 롤백될지 예측하기 어려움
}

// ✅ 명확한 트랜잭션 경계
@Transactional
public void atomicOperation() {
    // 반드시 함께 성공/실패해야 하는 작업만 포함
    repository.save(entity1);
    repository.save(entity2);
}

public void compositeOperation() {
    // 독립적으로 실행 가능한 작업들
    Result1 result1 = service1.independentOperation1(); // 각자 @Transactional
    Result2 result2 = service2.independentOperation2(); // 각자 @Transactional
    
    // 필요시 보상 로직
    if (result2.isFailed()) {
        service1.compensate(result1);
    }
}
```

### rollback-only 마킹이란?
Spring이 트랜잭션 내부에 "이 트랜잭션은 반드시 롤백되어야 한다"는 플래그를 설정하는 것

**언제 마킹되나?**
- 트랜잭션 내에서 RuntimeException(또는 Error) 발생 시
- 체크 예외라도 @Transactional(rollbackFor = Exception.class) 설정 시

**왜 문제가 되나?**
- 개발자의 착각: 예외를 catch했으니 문제없다고 생각
- Spring의 판단: "어? rollback-only인데 정상 종료? 뭔가 이상하다!"
- 결과: UnexpectedRollbackException 발생

**실무에서 자주 겪는 실수**
```java
@Transactional
public void processOrder() {
    try {
        paymentService.charge(); // 여기서 예외 → rollback-only 마킹
        inventoryService.reduce(); // 실행되지만 어차피 롤백될 예정
    } catch (PaymentException e) {
        // 결제 실패를 처리했다고 생각하지만...
        notificationService.sendFailureEmail(); // 이것도 롤백됨!
        // UnexpectedRollbackException 발생!
    }
}
```

```java
// rollback-only 마킹의 동작 원리

// Spring 트랜잭션의 내부 상태
public class TransactionStatus {
    private boolean rollbackOnly = false;  // 이 플래그가 핵심!
    private boolean completed = false;
    // ... 기타 상태들
}

// 1. 정상적인 트랜잭션 흐름
@Transactional
public void normalFlow() {
    // TransactionStatus.rollbackOnly = false (초기값)
    
    repository.save(entity1);  // 성공
    repository.save(entity2);  // 성공
    
    // 메서드 종료 시: rollbackOnly == false
    // → Spring이 commit() 실행
}

// 2. 예외 발생 시 rollback-only 마킹
@Transactional
public void exceptionFlow() {
    // TransactionStatus.rollbackOnly = false (초기값)
    
    repository.save(entity1);  // 성공
    
    if (someCondition) {
        throw new RuntimeException("오류 발생!");
        // → Spring이 rollbackOnly = true로 마킹!
    }
    
    // 메서드 종료 시: rollbackOnly == true  
    // → Spring이 rollback() 실행
}

// 3. 문제 상황: 중첩 트랜잭션에서 예외 처리

@Service
public class UserService {
    @Transactional
    public void createUser(User user) {
        userRepository.save(user);
        
        if (user.getEmail().contains("test")) {
            // 여기서 RuntimeException 발생!
            throw new IllegalArgumentException("테스트 이메일 불허");
        }
    }
}

@Service 
public class AuthFacade {
    @Transactional  // 외부 트랜잭션 시작
    public void signUp(CreateUserReq req) {
        
        // === 트랜잭션 상태: rollbackOnly = false ===
        
        try {
            userService.createUser(user);  // 내부 트랜잭션 (같은 TX에 참여)
            
            // createUser() 내부에서 IllegalArgumentException 발생
            // Spring이 감지하고 → rollbackOnly = true로 마킹!
            
        } catch (IllegalArgumentException e) {
            // === 트랜잭션 상태: rollbackOnly = true ===
            
            log.warn("사용자 생성 실패: {}", e.getMessage());
            
            // 개발자는 예외를 처리했다고 생각하지만...
            // 트랜잭션은 이미 rollback-only로 마킹된 상태!
            
            // 이후 코드 실행해도 의미 없음
            emailService.createEmailVerification(user, token);
        }
        
        // === 메서드 종료 시점 ===
        // Spring: "어? rollbackOnly가 true네? 그런데 정상 종료했네?"
        // Spring: "뭔가 이상하다... UnexpectedRollbackException 던져야지!"
    }
}

// 4. 실제 Spring 내부 동작 (의사코드)

public class TransactionManager {
    
    public void handleTransactionEnd(TransactionStatus status) {
        if (status.isRollbackOnly()) {
            if (status.isCompletedNormally()) {
                // 모순된 상황: rollback-only인데 정상 종료?
                throw new UnexpectedRollbackException(
                    "Transaction rolled back because it has been marked as rollback-only"
                );
            } else {
                // 예외로 종료 → 정상적인 rollback
                rollback();
            }
        } else {
            // 정상적인 commit
            commit();
        }
    }
}

// 5. 타임라인으로 보는 상세 과정

/*
Time | Method                    | Transaction State           | DB State
-----|---------------------------|----------------------------|------------------
T1   | AuthFacade.signUp() 시작   | rollbackOnly = false       | TX 시작
T2   | UserService.createUser()   | rollbackOnly = false       | user 저장됨
T3   | IllegalArgumentException  | rollbackOnly = true 마킹!   | user 여전히 있음 (아직 rollback 안됨)
T4   | catch 블록 진입            | rollbackOnly = true        | user 여전히 있음
T5   | emailService 호출          | rollbackOnly = true        | 실행되지만 의미없음
T6   | signUp() 메서드 종료        | rollbackOnly = true        | Spring이 UnexpectedRollbackException 발생
T7   | 최종 rollback 실행         | 트랜잭션 종료               | 모든 변경사항 롤백 (user 삭제됨)
*/

// 6. 올바른 해결 방법들

// 방법 1: 예외를 다시 던지기
@Transactional
public void signUp(CreateUserReq req) {
    try {
        userService.createUser(user);
        emailService.createEmailVerification(user, token);
    } catch (IllegalArgumentException e) {
        log.warn("사용자 생성 실패: {}", e.getMessage());
        throw e; // 예외를 다시 던져서 정상적인 rollback 처리
    }
}

// 방법 2: 독립적인 트랜잭션으로 분리
public void signUp(CreateUserReq req) { // @Transactional 제거
    try {
        User user = userService.createUser(req);  // 독립 TX1
        emailService.createEmailVerification(user, token); // 독립 TX2
    } catch (IllegalArgumentException e) {
        log.warn("사용자 생성 실패: {}", e.getMessage());
        // 각각이 독립적이므로 문제없음
    }
}

// 방법 3: 검증을 미리 분리
@Transactional
public void signUp(CreateUserReq req) {
    // 트랜잭션 시작 전에 검증
    validateUser(req); // 예외 발생 가능, 하지만 트랜잭션 밖
    
    // 검증 통과 후 트랜잭션 내 작업
    User user = userService.createUser(req);
    emailService.createEmailVerification(user, token);
}

// 방법 4: REQUIRES_NEW로 독립 트랜잭션
@Service
public class UserService {
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void createUser(User user) {
        // 완전히 새로운 트랜잭션에서 실행
        // 예외 발생해도 외부 트랜잭션에 영향 없음
        userRepository.save(user);
        
        if (user.getEmail().contains("test")) {
            throw new IllegalArgumentException("테스트 이메일 불허");
        }
    }
}

// 7. rollback-only 상태 확인하는 방법
@Transactional
public void signUp(CreateUserReq req) {
    try {
        userService.createUser(user);
    } catch (IllegalArgumentException e) {
        // 현재 트랜잭션 상태 확인
        if (TransactionSynchronizationManager.isCurrentTransactionReadOnly() ||
            TransactionAspectSupport.currentTransactionStatus().isRollbackOnly()) {
            
            log.warn("트랜잭션이 rollback-only로 마킹됨. 추가 작업 중단.");
            throw e; // 예외 재발생으로 정상적인 rollback 유도
        }
        
        // rollback-only가 아니라면 계속 진행 (실제로는 거의 없는 경우)
        emailService.createEmailVerification(user, token);
    }
}
```