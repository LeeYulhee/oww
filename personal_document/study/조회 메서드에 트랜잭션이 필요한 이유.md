### 경우에 따라 다르지만 일반적으로 있는 게 좋음

트랜잭션이 없는 조회:
```java
javapublic User findUser() {
    return userRepository.findById(1L); // 트랜잭션 없음
}
```
- DB 커넥션을 매번 새로 가져옴
- 쿼리 실행 후 즉시 커넥션 반환

<br>

트랜잭션이 있는 조회:
```java
@Transactional(readOnly = true)
public User findUser() {
    return userRepository.findById(1L); // 트랜잭션 있음
}
```
**트랜잭션이 있으면 좋은 이유:**
- Lazy Loading 보장: JPA에서 연관관계 데이터를 나중에 가져올 때 트랜잭션 필요
- 일관된 읽기: 같은 트랜잭션 내에서 데이터 일관성 보장
- DB 최적화: readOnly=true로 DB에게 힌트 제공


**트랜잭션이 꼭 필요한 경우:**
- Lazy Loading 사용: 연관관계 데이터를 나중에 가져올 때
- 여러 쿼리 실행: 한 메서드에서 여러 Repository 호출할 때
- 복잡한 비즈니스 로직: 데이터 일관성이 중요할 때

**트랜잭션이 없어도 되는 경우:**
- 단순 조회: 한 번의 쿼리로 끝나는 경우
- Eager Loading: 모든 데이터를 한 번에 가져오는 경우
- 기본 타입 반환: boolean, int 등 단순 값만 리턴

**현실적인 접근:**

- 클래스 레벨에 @Transactional(readOnly = true): 안전하고 편함
- 성능 차이는 미미함: 단순 조회에서는 트랜잭션 오버헤드가 크지 않음
- Lazy Loading 실수 방지: 나중에 코드 수정할 때 예상치 못한 오류 방지

```java
@Entity
public class User {
    @OneToMany(fetch = FetchType.LAZY) // 기본값
    private List<WorkoutRecord> workoutRecords;
}

// 문제가 되는 코드
public class UserService {
    
    // 트랜잭션 없음
    public User findUserWithWorkouts(UUID userId) {
        User user = userRepository.findById(userId).get();
        
        // 여기서 LazyInitializationException 발생!
        // 이미 DB 커넥션이 닫혔는데 workoutRecords를 가져오려고 시도
        int workoutCount = user.getWorkoutRecords().size();
        
        return user;
    }
}

// 해결된 코드
public class UserService {
    
    @Transactional(readOnly = true) // 트랜잭션 있음
    public User findUserWithWorkouts(UUID userId) {
        User user = userRepository.findById(userId).get();
        
        // 트랜잭션이 있어서 DB 커넥션이 살아있음
        // Lazy Loading 성공!
        int workoutCount = user.getWorkoutRecords().size();
        
        return user;
    }
}

// 2. 커넥션 풀 효율성

// 트랜잭션 없는 경우
public User findUser() {
    // 매번 새로운 커넥션 요청
    return userRepository.findById(1L); // 커넥션 1번
}

public List<WorkoutRecord> findWorkouts() {
    // 또 다른 커넥션 요청  
    return workoutRepository.findByUserId(1L); // 커넥션 2번
}

// 컨트롤러에서
public void someController() {
    User user = userService.findUser();           // 커넥션 1 사용 후 반환
    List<WorkoutRecord> workouts = workoutService.findWorkouts(); // 커넥션 2 사용 후 반환
}

// 트랜잭션 있는 경우
@Transactional(readOnly = true)
public UserWithWorkouts findUserWithWorkouts() {
    User user = userRepository.findById(1L);              // 커넥션 1 사용
    List<WorkoutRecord> workouts = workoutRepository.findByUserId(1L); // 같은 커넥션 1 재사용
    return new UserWithWorkouts(user, workouts);
}

// 3. 실제로는 언제 트랜잭션이 필요하고 불필요한가?

// 트랜잭션이 꼭 필요한 경우들:
public class UserService {
    
    // ❌ 트랜잭션 없으면 LazyInitializationException
    public UserDto getUserWithDetails(UUID userId) {
        User user = userRepository.findById(userId).get();
        
        // Lazy Loading 발생
        List<String> groupNames = user.getGroupMembers().stream()
            .map(member -> member.getGroup().getGroupName())
            .toList();
            
        return UserDto.builder()
            .user(user)
            .groupNames(groupNames)
            .build();
    }
    
    // ❌ 트랜잭션 없으면 여러 쿼리가 각각 다른 커넥션 사용
    public UserStats getUserStats(UUID userId) {
        User user = userRepository.findById(userId).get();      // 쿼리 1
        int workoutCount = workoutRepository.countByUserId(userId); // 쿼리 2  
        int groupCount = groupRepository.countByUserId(userId);     // 쿼리 3
        
        return new UserStats(user, workoutCount, groupCount);
    }
}

// 트랜잭션이 없어도 되는 경우들:
public class UserService {
    
    // ✅ 단순 조회, Lazy Loading 없음
    public User findByEmail(String email) {
        return userRepository.findByEmail(email)
            .orElseThrow(() -> new IllegalArgumentException("사용자를 찾을 수 없습니다"));
    }
    
    // ✅ 단순 존재 여부 확인
    public boolean existsByEmail(String email) {
        return userRepository.existsByEmail(email);
    }
}

// 4. 현실적인 접근법

@Service
@Transactional(readOnly = true) // 기본값으로 설정
public class UserService {
    
    // 복잡한 조회 - 트랜잭션 혜택을 받음
    public UserDetailDto getUserDetail(UUID userId) {
        User user = userRepository.findById(userId).get();
        // Lazy Loading 안전하게 사용 가능
        return UserDetailDto.from(user);
    }
    
    // 단순 조회 - 트랜잭션이 있어도 성능에 큰 영향 없음  
    public User findByEmail(String email) {
        return userRepository.findByEmail(email)
            .orElseThrow(() -> new IllegalArgumentException("사용자를 찾을 수 없습니다"));
    }
    
    @Transactional // 쓰기 작업
    public void createUser(User user) {
        userRepository.save(user);
    }
}

// 5. 성능 비교 예시 (의사코드)

// 트랜잭션 없음 - 매번 커넥션 획득/반환
Method: findUser()
├─ Connection.acquire()     // 10ms
├─ SELECT * FROM users      // 5ms  
└─ Connection.release()     // 5ms
Total: 20ms

// 트랜잭션 있음 - 커넥션 재사용
Method: findUserWithDetails()  
├─ Transaction.begin() + Connection.acquire()  // 10ms
├─ SELECT * FROM users                         // 5ms
├─ SELECT * FROM workout_records (lazy)        // 5ms
├─ SELECT * FROM groups (lazy)                 // 5ms
└─ Transaction.commit() + Connection.release() // 5ms
Total: 30ms (vs 60ms if separate transactions)
```

### 결론: 권장 패턴
**✅ Service에만 클래스 레벨 @Transactional(readOnly = true)**
- 이유: Service는 조회 메서드가 80% 이상
- 장점: Lazy Loading 안전, 일관된 트랜잭션 관리
- 단점: 거의 없음

**❌ Facade에는 클래스 레벨 @Transactional 지양**
- 이유: Facade는 조회+쓰기가 섞여있어서 readOnly 기본값이 맞지 않음
- 대신: 필요한 메서드만 명시적으로 @Transactional 추가

**📋 실제 적용 예시**
```java
// ✅ Service
@Service
@Transactional(readOnly = true)
public class UserService { ... }

@Service  
@Transactional(readOnly = true)
public class EmailVerificationService { ... }

// ✅ Facade  
@Service // 클래스 레벨 트랜잭션 없음
public class AuthFacade {
    
    public void resendEmail() { ... }  // 조회만 → Service TX 활용
    
    @Transactional // 원자성 필요
    public void verifyEmail() { ... }
    
    public void signUp() { ... }  // 독립 실행 → Service별 TX
}
```

```java
// Service vs Facade 트랜잭션 설계 비교

// ✅ 추천: Service에만 클래스 레벨 @Transactional
@Service
@Transactional(readOnly = true) // 👍 좋음
public class UserService {
    
    public User findByEmail(String email) {
        // readOnly=true 트랜잭션에서 실행
        return userRepository.findByEmail(email)
            .orElseThrow(() -> new IllegalArgumentException("사용자를 찾을 수 없습니다"));
    }
    
    @Transactional // readOnly=false로 오버라이드
    public void createUser(User user) {
        userRepository.save(user);
    }
}

@Service
@Transactional(readOnly = true) // 👍 좋음  
public class EmailVerificationService {
    
    public EmailVerification findByToken(String token) {
        // readOnly=true 트랜잭션에서 실행
        return repository.findByToken(token)
            .orElseThrow(() -> new IllegalArgumentException("유효하지 않은 토큰"));
    }
    
    @Transactional // readOnly=false로 오버라이드
    public void createEmailVerification(User user, String token) {
        // 저장 로직
    }
}

// ❌ 비추천: Facade에 클래스 레벨 @Transactional
@Service
@Transactional(readOnly = true) // 👎 문제 많음
public class AuthFacade {
    
    // 문제 1: 모든 메서드가 readOnly 트랜잭션
    public void signUp(CreateUserReq req) {
        // readOnly=true 트랜잭션이 시작됨
        userService.createUser(user);                    // 쓰기 작업인데 readOnly?
        emailService.createEmailVerification(user, token); // 쓰기 작업인데 readOnly?
        
        // Spring: "readOnly 트랜잭션에서 쓰기 시도? 오류 발생!"
    }
    
    // 모든 쓰기 메서드마다 @Transactional 오버라이드 필요
    @Transactional // 👎 번거로움
    public void verifyEmail(String token) {
        // ...
    }
    
    @Transactional // 👎 번거로움  
    public void resetPassword(String email) {
        // ...
    }
}

// ✅ 추천: Facade는 트랜잭션 설정 없이, 필요한 곳만 명시적으로
@Service // 클래스 레벨 @Transactional 없음
public class AuthFacade {
    
    // 조회만 하는 메서드 - 트랜잭션 설정 없음 (각 Service에서 관리)
    public void resendEmail(ResendEmailReq req) {
        User user = userService.findByEmailAndIsDeletedFalse(req.getEmail()); // Service의 readOnly TX
        EmailVerification verification = emailService.findByToken(token);      // Service의 readOnly TX
        
        applicationEventPublisher.publishEvent(new ResendVerificationEmailEvent(user.getEmail(), verification.getVerificationToken()));
    }
    
    // 원자성이 필요한 메서드만 명시적으로 @Transactional
    @Transactional
    public void verifyEmail(String token) {
        EmailVerification verification = getValidEmailVerification(token);
        User user = verification.getUser();

        // 두 작업이 하나의 트랜잭션에서 실행되어야 함
        userService.updateUserStatusActive(user);
        emailVerificationService.updateEmailVerification(verification);
    }
    
    // 각각 독립 트랜잭션으로 실행하고 싶은 메서드 - @Transactional 없음
    public void signUp(CreateUserReq req) {
        User user = CreateUserReq.toEntity(req, passwordEncoder.encode(req.getPassword()));
        userService.createUser(user);               // 독립 트랜잭션 1

        String emailToken = tokenService.generateVerificationToken(user.getId(), user.getEmail(), VerificationType.SIGNUP);
        emailVerificationService.createEmailVerification(user, emailToken); // 독립 트랜잭션 2

        applicationEventPublisher.publishEvent(new SendVerificationEmailEvent(user.getEmail(), emailToken));
    }
}

// 실제 실행 흐름 비교

// Case 1: Service만 @Transactional(readOnly=true)
/*
AuthFacade.resendEmail() 호출
├─ userService.findByEmail() → readOnly TX 생성 → 조회 → TX 종료
├─ emailService.findByToken() → readOnly TX 생성 → 조회 → TX 종료  
└─ 이벤트 발행 (트랜잭션 외부)

AuthFacade.verifyEmail() 호출 (@Transactional 명시)
├─ AuthFacade TX 시작 (readOnly=false)
├─ userService.updateStatus() → 기존 TX 참여
├─ emailService.updateVerification() → 기존 TX 참여
└─ AuthFacade TX 커밋
*/

// Case 2: Facade에도 @Transactional(readOnly=true) - 문제 발생
/*
AuthFacade.signUp() 호출
├─ AuthFacade readOnly TX 시작 ❌
├─ userService.createUser() → readOnly TX에 참여하려 함
│   └─ 쓰기 작업 시도 → SQLException 또는 TransactionException 발생! ❌
└─ 실패
*/

// 왜 Facade에 readOnly를 붙이면 안 되는가?

// 1. Facade의 역할
/*
- 여러 Service를 조합하는 역할
- 비즈니스 플로우 관리
- 트랜잭션 경계 결정 (원자성이 필요한 경우만)
- 대부분 조회+쓰기가 섞여있음
*/

// 2. Service의 역할  
/*
- 단일 도메인의 비즈니스 로직
- 대부분 조회 메서드가 많음 (CRUD 중 R이 80%)
- readOnly 기본값이 합리적
*/

// 3. 권장 패턴 정리
@Service
@Transactional(readOnly = true) // ✅ Service: 조회 중심이므로 readOnly 기본값
public class UserService {
    
    public User findUser() { /* readOnly */ }
    public List<User> findUsers() { /* readOnly */ }
    public boolean existsUser() { /* readOnly */ }
    
    @Transactional // 쓰기 작업만 명시적으로 오버라이드
    public void createUser() { /* 쓰기 */ }
    
    @Transactional
    public void updateUser() { /* 쓰기 */ }
}

@Service // ✅ Facade: 트랜잭션 정책을 명시적으로 관리
public class AuthFacade {
    
    // 조회만 → 트랜잭션 설정 없음 (Service에 위임)
    public SomeDto getSomeData() {
        return userService.findUser(); // Service의 readOnly TX 사용
    }
    
    // 원자성 필요 → 명시적 @Transactional
    @Transactional  
    public void atomicOperation() {
        userService.updateUser();
        emailService.updateEmail();
    }
    
    // 독립 실행 원함 → @Transactional 없음
    public void independentOperations() {
        userService.createUser();  // 독립 TX1
        emailService.sendEmail();  // 독립 TX2
    }
}
```